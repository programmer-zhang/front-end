### 写在前面的话
> 缓存对于web开发有重要作用，尤其是大负荷web系统开发中。
> 想了解更多关于性能优化的知识,请移步[HTML、CSS、JS优化](./[前端性能优化]HTML、CSS、JS篇.md)、 [页面加载速度优化](./[前端性能优化]页面加载速度优化.md)、 [网络传输层优化](./[前端性能优化]网络传输层优化.md)

## 缓存
* 缓存的分类：服务器缓存，第三方缓存，浏览器缓存等。
* 浏览器缓存是代价最小的，因为浏览器缓存依赖的是客户端，而几乎不耗费服务器端的资源(极端情况下相当于纯静态页面)。
* 让浏览器做缓存需要给浏览器发送指定的Http头，告诉浏览器缓存多长时间，或者坚决不要缓存。

## HTTP-header
### Expires（过期时间）(强缓存机制)
* HTTP头信息Expires（过期时间） 属性是HTTP控制缓存的基本手段
* 是一个GMT时间格式的绝对时间间隔
* 作用：告诉缓存器相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修改。
* 几乎所有的缓存服务器都支持Expires（过期时间）属性
* 基于客户最后查看副本的时间（最后访问时间）或者根据服务器上文档最后被修改的时间
* 对于设置静态图片文件（例如导航栏和图片按钮）可缓存特别有用；因为这些图片修改很少，你可以给它们设置一个特别长的过期时间，这会使你的网站对用户变得相应非常快
* 对于控制有规律改变的网页也很有用，例如：你每天早上6点更新新闻页，你可以设置副本的过期时间也是这个时间，这样缓存服务器就知道什么时候去取一个更新版本，而不必让用户去按浏览器的“刷新”按钮。
* 过期时间头信息属性值只能是HTTP格式的日期时间，其他的都会被解析成当前时间“之前”，副本会过期
* HTTP的日期时间必须是格林威治时 间（GMT），而不是本地时间。
* 举例：Expires: Fri, 30 Oct 1998 14:19:41
* 虽然过期时间属性非常有用，但是它还是有些局限，
	* 首先：是牵扯到了日期，这样Web服务器的时间和缓存服务器的时间必须是同步的，如果有些不同步，要么是应该缓存的内容提前过期了，要么是过期结果没及时更新。
	* 如果你设置的过期时间是一个固定的时间，如果你返回内容的时候又没有连带更新下次过期的时间，那么之后所有访问请求都会被发送给源Web服务器，反而增加了负载和响应时间

### Cache-Control（缓存控制）(强缓存机制)
* 让网站的发布者可以更全面的控制他们的内容，并定位过期时间的限制。
* max-age=[秒] — 执行缓存被认为是最新的最长时间。
	* 相对时间，不是绝对时间
	* 单位是秒：从请求时间 开始到过期时间之间的秒数。
* s-maxage=[秒] — 类似于max-age属性，除了他应用于共享（如：代理服务器）缓存
* public — 标记认证内容也可以被缓存，一般来说： 经过HTTP认证才能访问的内容，输出是自动不可以缓存的；
* no-cache — 强制每次请求直接发送给源服务器，而不经过本地缓存版本的校验。这对于需要确认认证应用很有用（可以和public结合使用），或者严格要求使用最新数据 的应用（不惜牺牲使用缓存的所有好处）；
* no-store — 强制缓存在任何情况下都不要保留任何副本
* must-revalidate — 告诉缓存必须遵循所有你给予副本的新鲜度的
* proxy-revalidate — 和 must-revalidate 类似，除了他只对缓存代理服务器起作用

### Last-Modified/If-Modified-Since (协商缓存机制)
* 通常服务器知道你所请求的数据的最后修改时间，并且 HTTP 为服务器提供了一种将最近修改数据连同你请求的数据一同发送的方法。
* 如果你第二次 (或第三次，或第四次) 请求相同的数据，告诉服务器上一次获得的最后修改日期：在请求中发送一个 If-Modified-Since 头信息，它包含了上一次从服务器连同数据所获得的日期。
* 如果数据从那时起没有改变，服务器将返回一个特殊的 HTTP 状态代码 304，这意味着 “从上一次请求后这个数据没有改变”。
* 当服务器发送状态编码 304 时，不再重新发送数据。所以当数据没有更新时，你不需要一次又一次地下载相同的数据
* 所有现代的浏览器都支持 (last-modified) 的数据检查。

### ETag/If-None-Match (协商缓存机制)
* ETag : 没有变化时不重新下载数据。
* 工作方式 : 服务器发送响应数据的同时，发送某种数据的 hash (在 ETag 头信息中给出)。hash 的确定完全取决于服务器。当第二次请求相同的数据时，你需要在 If-None-Match: 头信息中包含 ETag hash，如果数据没有改变，服务器将返回 304 状态代码。与最近修改数据检查相同，服务器仅仅 发送 304 状态代码；第二次将不为你发送相同的数据。在第二次请求时，通过包含 ETag hash

## 几种缓存策略的对比
* 