## JS 浮点数计算

### 写在前面
> JavaScript中有些特殊的计算结果，如 `0.1 + 0.2 = 0.30000000000000004`(这个问题不止在JavaScript中存在，在C++、java语言中都存在这个问题，只不过这些强类型语言封装好了方法来解决这个问题。)想必大家都知道这是由于存储时数据长度截取造成的问题，但是计算机是如何存储计算这些数值的呢，本文结合多个计算机基础知识解释这点。

## 阅读本文您将收获
* 十进制与二进制间的转换
* 计算机原码补码反码的计算
* 计算机存储计算 JavaScript 数值的原理

> 想弄清楚计算机 `0.1+0.2` 的计算原理，需要提前了解以下知识

## 十进制与二进制转换
> 计算机字长是指进行运算的二进制位数，有8，16，32，64位之分，主要取决于数据总线的宽度。比如说奔腾是32位，这是指处理器的寄存器能保存32位的数据。

##### 正整数的转换
* 除二取余，倒序排列，高位补零
* 为什么需要补位：计算机存储时按照CPU根据数据总线的宽度，决定寄存器可以保存多少位的数据

![](../images/mathFloat/10to2.png)

##### 负整数的转换
* 将负整数的绝对值转换成二进制，各位取反后 +1

##### 浮点数的转换
* 整数位正常转换，小数部分乘2取整，顺序排列

![](../images/mathFloat/10floatto2.png)

## 原码、补码、反码

## 浮点数在计算机中的存储

1. 浮点数转换成二进制，并采用科学计数法表示。
2. 浮点型的存储实现是按照 `IEEE754标准` 的，可分为两种：

* 单精度Float--32位(4字节)
* 双精度Double--64位(8字节)

##### IEEE标准
> 20世纪80年代前每个计算机制造商都自定义自己的表示浮点数的规则，及浮点数执行运算的细节。而且不太关注运算的精确性，而是更多地关注速度和简便性。

> 1985年左右推出IEEE 754标准的浮点数表示和运算规则，才让浮点数的表示和运算均有可移植性。

二进制浮点数算术标准IEEE中的存储格式为：

```
E =  (-1)^S × M × 2^E
```
* (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
* M表示指数位，用来表示次方数，大于等于1，小于2。
* 2^E表示指数位。

##### 存储格式
* 对于单精度浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。

![](../images/mathFloat/floatspace.png)

* 对于双精度的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

![](../images/mathFloat/doublespace.png)

JavaScript中只有一种数字相关类型 -- Number ,并使用双精度浮点数存储，以64位固定长度来表示，相当于标准的 double 双精度浮点数

##### 计算详情
1. 先把是十进制数转为二进制，但是 `0.1` 和 `0.2` 用二进制表示时是无穷的

	```
	0.1 --> 0.0001 1001 1001 1001...
	0.2 --> 0.0011 0011 0011 0011...
	```
2. 两者相加，由于 `IEEE 754` 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位,所以会将超出的二进制部分进行截断得到：

	```
	0.0100110011001100110011001100110011001100110011001100
	```
3. 再转换为十进制，就变成了 `0.30000000000000004`

## 解决方式
1. 浮点数转化成整数，再进行计算
2. 使用 `toFixed() `进行四舍五入
3.  自定义处理函数
4. 引用类库 
	* [Math.js](https://mathjs.org/)
	* [decimal.js](http://mikemcl.github.io/decimal.js/)